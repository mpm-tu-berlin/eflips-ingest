# (CHOICE 1: REST) `eflips-ingest` API Specification

The `eflips-ingest` API is designed in order to provide a standardized access method to the different ingesters. It is
designed as a reusable [django](https://docs.djangoproject.com) app providing a web API. This API is oriented towards
RESTful principles, however the `/api/ingest/ingesters/$ingester_id$/begin?UUID=$uuid$` requires that the data was 
POSTed to the `/api/ingesters/$ingester_id$` upload endpoint and a scenario UUID was returned.

## Endpoints

### `/api/ingest/ingesters`

#### `GET /api/ingest/ingesters`

This returns a JSON-Formatted Dict of all available ingesters. The keys are the ingester IDs and the values are a tuple
of name and description. *Note for RLI: We don't do localization, right?*

### `/api/ingest/ingesters/$ingester_id$`

#### `GET /api/ingest/ingesters/$ingester_id$`

This returns a list of dictionaries the ingester's additional parameters, if any. From this dictionary, a form can be
constructed to POST to the `/api/ingest/ingesters/$ingester_id$` endpoint. This dictionary contains a list of 
dictionaries with the following keys:

- `name`: The name of the parameter in the form and POST request
- `type`: The type of the parameter. Currently supported are `str`, `int`, `float`, `bool`, `date`, `datetime`, `time`, `file`
- `required`: A boolean indicating whether the parameter is required
- `default`: The default value of the parameter. May be `null`
- `choices`: A list of choices for the parameter. May be `null`
- `help_text`: A string containing help text for the parameter. May be `null`

#### `POST /api/ingest/ingesters/$ingester_id$`

This endpoint is used to POST the data to the ingester. The data is expected to be a multipart/form-data request, 
containing all `required` parameters and no parameters not listed in the `GET` response. The uploaded data will then be 
**checked for validity** in synchronous mode and a **UUID** will be returned. This UUID can then be used to start the 
ingestion process by calling the `/api/ingest/ingesters/$ingester_id$/begin?UUID=$uuid$` endpoint.

If validation fails, a 400 Bad Request response will be returned, containing a list of dictionaries with the following
keys:
- `name`: A short name for the error
- `message`: A human-readable error longer message

### `/api/ingest/ingesters/$ingester_id$/begin`

#### `GET /api/ingest/ingesters/$ingester_id$/begin?UUID=$uuid$`

This endpoint is used to start the ingestion process. The UUID is the one returned by the 
`/api/ingest/ingesters/$ingester_id$` endpoint. The ingestion process will then be started asynchronously and the 202
Accepted response will be returned. The ingestion process can be monitored by calling the 
`/api/ingest/ingesters/$ingester_id$/status?UUID=$uuid$` endpoint.

### `/api/ingest/ingesters/$ingester_id$/status`

#### `GET /api/ingest/ingesters/$ingester_id$/status?UUID=$uuid$`

This endpoint is used to check the status of the ingestion process. The UUID is the one returned by the 
`/api/ingest/ingesters/$ingester_id$` endpoint. The response will be one of the following:

- 402 Payment Required: *Because we can*. The payload will be fixed to `{"status": "Payment Required"}`
- 404 Not Found: The UUID is not known. The payload will be fixed to `{"status": "Not Found"}`
- 500 Internal Server Error: An error occurred during the ingestion process. The payload will be fixed to `{"status": "Internal Server Error"}`. *Note that this should not happen, as we should catch all errors and return a 400 Bad Request response during the validation process.*
- 102 Processing: The ingestion process is still running. The payload will be to `{"status": "Processing", "progress": $progress$}` where `$progress$` is a float between 0 and 1, indicating the progress of the ingestion process. `progress` may be `null` if the progress is not known.
- 200 OK: The ingestion process has finished. The payload will be fixed to `{"status": "OK"}`. From this point, the scenario can be used in the simulation.

# CHOICE 2: Python Package

The `eflips-ingest` package is designed to provide a standardized access method to the different ingesters. It is
designed as a reusable [python](https://www.python.org) package providing a programmatic API. It provides the `Ingester`
class with the following methods:

- `__init__(self, database_url: str)`: The constructor. It takes the database URL as a parameter.
- `validate(self, **kwargs) -> Tuple[bool, UUID | Dict[str, str]]`: This method is used to validate the data. It
    has multiple keyword arguments, one for each parameter. It returns a tuple containing a boolean indicating whether 
    the data is valid and a UUID if the data is valid or a dictionary containing the error names and messages if the 
    data is invalid. It is suggested that the input form is generated by 
    [introspecting](https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object) 
    this method. If a UUID is returned, this UUID can be used to start the ingestion process, even with another instance
    of this Ingester class (the validated input data is saved to a temporary directory).
- `ingest(self, UUID: UUID, progress_callback: None | Callable(float)) -> None`: This method is used to start the 
    ingestion process. It takes the UUID returned by the `validate` method and a callback function that will be called 
    with the progress of the ingestion process. It is suggested that the progress is displayed in the UI. This method
    may raise an exception if the ingestion process fails. *Note that exceptions should not be raised during the
    ingest process if everything goes well, as we are checking validity in the `validate` method.*
- `name(cls) -> str`: This method returns the name of the ingester.
- `description(cls) -> str`: This method returns the description of the ingester.

In addition, the package provides a `get_ingesters` function that returns a list of `Ingester` classes.